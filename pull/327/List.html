<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Array.html">Array</a></li></li><li><li><a href="Blob.html">Blob</a></li></li><li><li><a href="Bool.html">Bool</a></li></li><li><li><a href="CertifiedData.html">CertifiedData</a></li></li><li><li><a href="Char.html">Char</a></li></li><li><li><a href="Cycles.html">Cycles</a></li></li><li><li><a href="Debug.html">Debug</a></li></li><li><li><a href="Error.html">Error</a></li></li><li><li><a href="Float.html">Float</a></li></li><li><li><a href="Func.html">Func</a></li></li><li><li><a href="Int.html">Int</a></li></li><li><li><a href="Int16.html">Int16</a></li></li><li><li><a href="Int32.html">Int32</a></li></li><li><li><a href="Int64.html">Int64</a></li></li><li><li><a href="Int8.html">Int8</a></li></li><li><li><a href="InternetComputer.html">InternetComputer</a></li></li><li><li><a href="Iter.html">Iter</a></li></li><li><li><a href="List.html">List</a></li></li><li><li><a href="Map.html">Map</a></li></li><li><li><a href="Nat.html">Nat</a></li></li><li><li><a href="Nat16.html">Nat16</a></li></li><li><li><a href="Nat32.html">Nat32</a></li></li><li><li><a href="Nat64.html">Nat64</a></li></li><li><li><a href="Nat8.html">Nat8</a></li></li><li><li><a href="Option.html">Option</a></li></li><li><li><a href="Order.html">Order</a></li></li><li><li><a href="Principal.html">Principal</a></li></li><li><li><a href="Queue.html">Queue</a></li></li><li><li><a href="Random.html">Random</a></li></li><li><li><a href="Region.html">Region</a></li></li><li><li><a href="Result.html">Result</a></li></li><li><li><a href="Runtime.html">Runtime</a></li></li><li><li><a href="Set.html">Set</a></li></li><li><li><a href="SimpleDebuggerTest.html">SimpleDebuggerTest</a></li></li><li><li><a href="SimpleDebuggerTestWithBase.html">SimpleDebuggerTestWithBase</a></li></li><li><li><a href="Stack.html">Stack</a></li></li><li><li><a href="Text.html">Text</a></li></li><li><li><a href="Time.html">Time</a></li></li><li><li><a href="Timer.html">Timer</a></li></li><li><li><a href="Tuples.html">Tuples</a></li></li><li><li><a href="Types.html">Types</a></li></li><li><li><a href="VarArray.html">VarArray</a></li></li><li><li><a href="internal/BTreeHelper.html">internal/BTreeHelper</a></li></li><li><li><a href="internal/PRNG.html">internal/PRNG</a></li></li><li><li><a href="pure/List.html">pure/List</a></li></li><li><li><a href="pure/Map.html">pure/Map</a></li></li><li><li><a href="pure/Queue.html">pure/Queue</a></li></li><li><li><a href="pure/RealTimeQueue.html">pure/RealTimeQueue</a></li></li><li><li><a href="pure/Set.html">pure/Set</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.List">List</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#singleton">singleton</a></li></li><li><li><a href="#repeat">repeat</a></li></li><li><li><a href="#toPure">toPure</a></li></li><li><li><a href="#fromPure">fromPure</a></li></li><li><li><a href="#addRepeat">addRepeat</a></li></li><li><li><a href="#clear">clear</a></li></li><li><li><a href="#clone">clone</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#filter">filter</a></li></li><li><li><a href="#filterMap">filterMap</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#add">add</a></li></li><li><li><a href="#removeLast">removeLast</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#getOpt">getOpt</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#sort">sort</a></li></li><li><li><a href="#indexOf">indexOf</a></li></li><li><li><a href="#lastIndexOf">lastIndexOf</a></li></li><li><li><a href="#find">find</a></li></li><li><li><a href="#findIndex">findIndex</a></li></li><li><li><a href="#findLastIndex">findLastIndex</a></li></li><li><li><a href="#all">all</a></li></li><li><li><a href="#any">any</a></li></li><li><li><a href="#values">values</a></li></li><li><li><a href="#enumerate">enumerate</a></li></li><li><li><a href="#reverseValues">reverseValues</a></li></li><li><li><a href="#reverseEnumerate">reverseEnumerate</a></li></li><li><li><a href="#keys">keys</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#addAll">addAll</a></li></li><li><li><a href="#toArray">toArray</a></li></li><li><li><a href="#fromArray">fromArray</a></li></li><li><li><a href="#toVarArray">toVarArray</a></li></li><li><li><a href="#fromVarArray">fromVarArray</a></li></li><li><li><a href="#first">first</a></li></li><li><li><a href="#last">last</a></li></li><li><li><a href="#forEach">forEach</a></li></li><li><li><a href="#forEachEntry">forEachEntry</a></li></li><li><li><a href="#reverseForEachEntry">reverseForEachEntry</a></li></li><li><li><a href="#reverseForEach">reverseForEach</a></li></li><li><li><a href="#contains">contains</a></li></li><li><li><a href="#max">max</a></li></li><li><li><a href="#min">min</a></li></li><li><li><a href="#equal">equal</a></li></li><li><li><a href="#compare">compare</a></li></li><li><li><a href="#toText">toText</a></li></li><li><li><a href="#foldLeft">foldLeft</a></li></li><li><li><a href="#foldRight">foldRight</a></li></li><li><li><a href="#reverseInPlace">reverseInPlace</a></li></li><li><li><a href="#reverse">reverse</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li></ul></nav><div class="documentation"><h1>List</h1><p>A mutable list data structure with efficient random access and dynamic resizing.
Provides O(1) access time and O(sqrt(n)) memory overhead.
Can be declared <code>stable</code> for orthogonal persistence.</p>
<p>This implementation is adapted with permission from the <code>vector</code> Mops package created by Research AG.</p>
<p>Copyright: 2023 MR Research AG
Main author: Andrii Stepanov
Contributors: Timo Hanke (timohanke), Andy Gura (andygura), react0r-com</p>
<pre><code>motoko name=import
import List &quot;mo:base/List&quot;;</code></pre><div class="declaration"><h4 class="type-declaration" id="type.List"><span class="keyword">type </span><span class="type">List</span>&lt;<span class="type">T</span>&gt; = <a href="Types.html#type.List"><span class="type">Types.List</span></a>&lt;<span class="type">T</span>&gt;</h4><p><p><code>List&lt;T&gt;</code> provides a mutable list of elements of type <code>T</code>.
Based on the paper &quot;Resizable Arrays in Optimal Time and Space&quot; by Brodnik, Carlsson, Demaine, Munro and Sedgewick (1999).
Since this is internally a two-dimensional array the access times for put and get operations
will naturally be 2x slower than Buffer and Array. However, Array is not resizable and Buffer
has <code>O(size)</code> memory waste.</p>
<p>The maximum number of elements in a <code>List</code> is 2^32.</p>
</p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">T</span>&gt;() : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a new empty List for elements of type T.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;(); // Creates a new List</code></pre></p></div><div class="declaration"><h4 class="function" id="singleton"><code><span class="keyword">public func </span><span class="fnname">singleton</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">element</span> : <span class="type">T</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns a new list with capacity and size 1, containing <code>element</code>.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.singleton&lt;Nat&gt;(1);
assert List.toText&lt;Nat&gt;(list, Nat.toText) == &quot;List[1]&quot;;</code></pre>

<p>Runtime: <code>O(1)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="repeat"><code><span class="keyword">public func </span><span class="fnname">repeat</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">initValue</span> : <span class="type">T</span>, <span class="parameter">size</span> : <span class="type">Nat</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a new List with <code>size</code> copies of the initial value.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.repeat&lt;Nat&gt;(2, 4);
assert List.toArray(list) == [2, 2, 2, 2];</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="toPure"><code><span class="keyword">public func </span><span class="fnname">toPure</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="pure/List.html#type.List"><span class="type">PureList.List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Converts a mutable <code>List</code> to a purely functional <code>PureList</code>.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.fromArray&lt;Nat&gt;([1, 2, 3]);
let pureList = List.toPure&lt;Nat&gt;(list); // converts to immutable PureList</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="fromPure"><code><span class="keyword">public func </span><span class="fnname">fromPure</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">pure</span> : <a href="pure/List.html#type.List"><span class="type">PureList.List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Converts a purely functional <code>List</code> to a mutable <code>List</code>.</p>
<p>Example:</p>
<pre><code>motoko include=import
import PureList &quot;mo:base/pure/List&quot;;

let pureList = PureList.fromArray&lt;Nat&gt;([1, 2, 3]);
let list = List.fromPure&lt;Nat&gt;(pureList); // converts to mutable List</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="addRepeat"><code><span class="keyword">public func </span><span class="fnname">addRepeat</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">initValue</span> : <span class="type">T</span>, <br/>  <span class="parameter">count</span> : <span class="type">Nat</span><br/>)</code></h4><p><p>Add to list <code>count</code> copies of the initial value.</p>
<pre><code>motoko include=import
let list = List.repeat&lt;Nat&gt;(2, 4); // [2, 2, 2, 2]
List.addRepeat(list, 2, 1); // [2, 2, 2, 2, 1, 1]</code></pre>

<p>The maximum number of elements in a <code>List</code> is 2^32.</p>
<p>Runtime: <code>O(count)</code></p>
</p></div><div class="declaration"><h4 class="function" id="clear"><code><span class="keyword">public func </span><span class="fnname">clear</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Resets the list to size 0, de-referencing all elements.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
List.add(list, 12);
List.clear(list); // list is now empty
assert List.toArray(list) == [];</code></pre>

<p>Runtime: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns a copy of a List, with the same size.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 1);

let clone = List.clone(list);
assert List.toArray(clone) == [1];</code></pre>

<p>Runtime: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">T</span>, <span class="type">R</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">R</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">R</span>&gt;</code></h4><p><p>Creates a new list by applying the provided function to each element in the input list.
The resulting list has the same size as the input list.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.singleton&lt;Nat&gt;(123);
let textList = List.map&lt;Nat, Text&gt;(list, Nat.toText);
assert List.toArray(textList) == [&quot;123&quot;];</code></pre>

<p>Runtime: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns a new list containing only the elements from <code>list</code> for which the predicate returns true.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.fromArray&lt;Nat&gt;([1, 2, 3, 4]);
let evenNumbers = List.filter&lt;Nat&gt;(list, func x = x % 2 == 0);
assert List.toArray(evenNumbers) == [2, 4];</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>predicate</code> runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="filterMap"><code><span class="keyword">public func </span><span class="fnname">filterMap</span>&lt;<span class="type">T</span>, <span class="type">R</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; ?<span class="type">R</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">R</span>&gt;</code></h4><p><p>Returns a new list containing all elements from <code>list</code> for which the function returns ?element.
Discards all elements for which the function returns null.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.fromArray&lt;Nat&gt;([1, 2, 3, 4]);
let doubled = List.filterMap&lt;Nat, Nat&gt;(list, func x = if (x % 2 == 0) ?(x * 2) else null);
assert List.toArray(doubled) == [4, 8];</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>f</code> runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Returns the current number of elements in the list.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
assert List.size(list) == 0</code></pre>

<p>Runtime: <code>O(1)</code> (with some internal calculations)</p>
</p></div><div class="declaration"><h4 class="function" id="add"><code><span class="keyword">public func </span><span class="fnname">add</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">element</span> : <span class="type">T</span>)</code></h4><p><p>Adds a single element to the end of a List,
allocating a new internal data block if needed,
and resizing the internal index block if needed.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 0); // add 0 to list
List.add(list, 1);
List.add(list, 2);
List.add(list, 3);
assert List.toArray(list) == [0, 1, 2, 3];</code></pre>

<p>The maximum number of elements in a <code>List</code> is 2^32.</p>
<p>Amortized Runtime: <code>O(1)</code>, Worst Case Runtime: <code>O(sqrt(n))</code></p>
</p></div><div class="declaration"><h4 class="function" id="removeLast"><code><span class="keyword">public func </span><span class="fnname">removeLast</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Removes and returns the last item in the list or <code>null</code> if
the list is empty.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
assert List.removeLast(list) == ?11;
assert List.removeLast(list) == ?10;
assert List.removeLast(list) == null;</code></pre>

<p>Amortized Runtime: <code>O(1)</code>, Worst Case Runtime: <code>O(sqrt(n))</code></p>
<p>Amortized Space: <code>O(1)</code>, Worst Case Space: <code>O(sqrt(n))</code></p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : <span class="type">T</span></code></h4><p><p>Returns the element at index <code>index</code>. Indexing is zero-based.
Traps if <code>index &gt;= size</code>, error message may not be descriptive.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
assert List.get(list, 0) == 10;</code></pre>

<p>Runtime: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="getOpt"><code><span class="keyword">public func </span><span class="fnname">getOpt</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : ?<span class="type">T</span></code></h4><p><p>Returns the element at index <code>index</code> as an option.
Returns <code>null</code> when <code>index &gt;= size</code>. Indexing is zero-based.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
assert List.getOpt(list, 0) == ?10;
assert List.getOpt(list, 2) == null;</code></pre>

<p>Runtime: <code>O(1)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">index</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">value</span> : <span class="type">T</span><br/>)</code></h4><p><p>Overwrites the current element at <code>index</code> with <code>element</code>.
Traps if <code>index</code> &gt;= size. Indexing is zero-based.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.put(list, 0, 20); // overwrites 10 at index 0 with 20
assert List.toArray(list) == [20];</code></pre>

<p>Runtime: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="sort"><code><span class="keyword">public func </span><span class="fnname">sort</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>)</code></h4><p><p>Sorts the elements in the list according to <code>compare</code>.
Sort is deterministic, stable, and in-place.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.empty&lt;Nat&gt;();
List.add(list, 3);
List.add(list, 1);
List.add(list, 2);
List.sort(list, Nat.compare);
assert List.toArray(list) == [1, 2, 3];</code></pre>

<p>Runtime: O(size * log(size))</p>
<p>Space: O(size)
*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="indexOf"><code><span class="keyword">public func </span><span class="fnname">indexOf</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : ?<span class="type">Nat</span></code></h4><p><p>Finds the first index of <code>element</code> in <code>list</code> using equality of elements defined
by <code>equal</code>. Returns <code>null</code> if <code>element</code> is not found.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.empty&lt;Nat&gt;();
List.add(list, 1);
List.add(list, 2);
List.add(list, 3);
List.add(list, 4);

assert List.indexOf&lt;Nat&gt;(list, Nat.equal, 3) == ?2;
assert List.indexOf&lt;Nat&gt;(list, Nat.equal, 5) == null;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>equal</code> runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="lastIndexOf"><code><span class="keyword">public func </span><span class="fnname">lastIndexOf</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : ?<span class="type">Nat</span></code></h4><p><p>Finds the last index of <code>element</code> in <code>list</code> using equality of elements defined
by <code>equal</code>. Returns <code>null</code> if <code>element</code> is not found.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.fromArray&lt;Nat&gt;([1, 2, 3, 4, 2, 2]);

assert List.lastIndexOf&lt;Nat&gt;(list, Nat.equal, 2) == ?5;
assert List.lastIndexOf&lt;Nat&gt;(list, Nat.equal, 5) == null;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>equal</code> runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="find"><code><span class="keyword">public func </span><span class="fnname">find</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : ?<span class="type">T</span></code></h4><p><p>Returns the first value in <code>list</code> for which <code>predicate</code> returns true.
If no element satisfies the predicate, returns null.</p>
<pre><code>motoko include=import
let list = List.fromArray&lt;Nat&gt;([1, 9, 4, 8]);
let found = List.find&lt;Nat&gt;(list, func(x) { x &gt; 8 });
assert found == ?9;</code></pre><p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="findIndex"><code><span class="keyword">public func </span><span class="fnname">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : ?<span class="type">Nat</span></code></h4><p><p>Finds the index of the first element in <code>list</code> for which <code>predicate</code> is true.
Returns <code>null</code> if no such element is found.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 1);
List.add(list, 2);
List.add(list, 3);
List.add(list, 4);

assert List.findIndex&lt;Nat&gt;(list, func(i) { i % 2 == 0 }) == ?1;
assert List.findIndex&lt;Nat&gt;(list, func(i) { i &gt; 5 }) == null;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>predicate</code> runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="findLastIndex"><code><span class="keyword">public func </span><span class="fnname">findLastIndex</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : ?<span class="type">Nat</span></code></h4><p><p>Finds the index of the last element in <code>list</code> for which <code>predicate</code> is true.
Returns <code>null</code> if no such element is found.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 1);
List.add(list, 2);
List.add(list, 3);
List.add(list, 4);

assert List.findLastIndex&lt;Nat&gt;(list, func(i) { i % 2 == 0 }) == ?3;
assert List.findLastIndex&lt;Nat&gt;(list, func(i) { i &gt; 5 }) == null;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>predicate</code> runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Returns true iff every element in <code>list</code> satisfies <code>predicate</code>.
In particular, if <code>list</code> is empty the function returns <code>true</code>.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 2);
List.add(list, 3);
List.add(list, 4);

assert List.all&lt;Nat&gt;(list, func x { x &gt; 1 });</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="any"><code><span class="keyword">public func </span><span class="fnname">any</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Returns true iff some element in <code>list</code> satisfies <code>predicate</code>.
In particular, if <code>list</code> is empty the function returns <code>false</code>.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 2);
List.add(list, 3);
List.add(list, 4);

assert List.any&lt;Nat&gt;(list, func x { x &gt; 3 });</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="values"><code><span class="keyword">public func </span><span class="fnname">values</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the elements of a List.
Iterator provides a single method <code>next()</code>, which returns
elements in order, or <code>null</code> when out of elements to iterate over.</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
List.add(list, 12);

var sum = 0;
for (element in List.values(list)) {
  sum += element;
};
assert sum == 33;</code></pre>

<p>Note: This does not create a snapshot. If the returned iterator is not consumed at once,
and instead the consumption of the iterator is interleaved with other operations on the
List, then this may lead to unexpected results.</p>
<p>Runtime: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="enumerate"><code><span class="keyword">public func </span><span class="fnname">enumerate</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;(<span class="type">Nat</span>, <span class="type">T</span>)&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the items (index-value pairs) in the list.
Each item is a tuple of <code>(index, value)</code>. The iterator provides a single method
<code>next()</code> which returns elements in order, or <code>null</code> when out of elements.</p>
<pre><code>motoko include=import
import Iter &quot;mo:base/Iter&quot;;

let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
List.add(list, 12);
assert Iter.toArray(List.enumerate(list)) == [(0, 10), (1, 11), (2, 12)];</code></pre>

<p>Note: This does not create a snapshot. If the returned iterator is not consumed at once,
and instead the consumption of the iterator is interleaved with other operations on the
List, then this may lead to unexpected results.</p>
<p>Runtime: <code>O(1)</code></p>
<p>Warning: Allocates memory on the heap to store ?(Nat, T).</p>
</p></div><div class="declaration"><h4 class="function" id="reverseValues"><code><span class="keyword">public func </span><span class="fnname">reverseValues</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the elements of the list in reverse order.
The iterator provides a single method <code>next()</code> which returns elements from
last to first, or <code>null</code> when out of elements.</p>
<pre><code>motoko include=import
let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
List.add(list, 12);

var sum = 0;
for (element in List.reverseValues(list)) {
  sum += element;
};
assert sum == 33;</code></pre>

<p>Note: This does not create a snapshot. If the returned iterator is not consumed at once,
and instead the consumption of the iterator is interleaved with other operations on the
List, then this may lead to unexpected results.</p>
<p>Runtime: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="reverseEnumerate"><code><span class="keyword">public func </span><span class="fnname">reverseEnumerate</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;(<span class="type">Nat</span>, <span class="type">T</span>)&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the items in reverse order, i.e. pairs of index and value.
Iterator provides a single method <code>next()</code>, which returns
elements in reverse order, or <code>null</code> when out of elements to iterate over.</p>
<pre><code>motoko include=import
import Iter &quot;mo:base/Iter&quot;;

let list = List.empty&lt;Nat&gt;();
List.add(list, 10);
List.add(list, 11);
List.add(list, 12);
assert Iter.toArray(List.reverseEnumerate(list)) == [(2, 12), (1, 11), (0, 10)];</code></pre>

<p>Note: This does not create a snapshot. If the returned iterator is not consumed at once,
and instead the consumption of the iterator is interleaved with other operations on the
List, then this may lead to unexpected results.</p>
<p>Runtime: <code>O(1)</code></p>
<p>Warning: Allocates memory on the heap to store ?(T, Nat).</p>
</p></div><div class="declaration"><h4 class="function" id="keys"><code><span class="keyword">public func </span><span class="fnname">keys</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">Nat</span>&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the indices (keys) of the list.
The iterator provides a single method <code>next()</code> which returns indices
from 0 to size-1, or <code>null</code> when out of elements.</p>
<pre><code>motoko include=import
import Iter &quot;mo:base/Iter&quot;;

let list = List.empty&lt;Text&gt;();
List.add(list, &quot;A&quot;);
List.add(list, &quot;B&quot;);
List.add(list, &quot;C&quot;);
Iter.toArray(List.keys(list)) // [0, 1, 2]</code></pre>

<p>Note: This does not create a snapshot. If the returned iterator is not consumed at once,
and instead the consumption of the iterator is interleaved with other operations on the
List, then this may lead to unexpected results.</p>
<p>Runtime: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">iter</span> : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a new List containing all elements from the provided iterator.
Elements are added in the order they are returned by the iterator.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;

let array = [1, 1, 1];
let iter = array.vals();

let list = List.fromIter&lt;Nat&gt;(iter);
assert Iter.toArray(List.values(list)) == [1, 1, 1];</code></pre>

<p>Runtime: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="addAll"><code><span class="keyword">public func </span><span class="fnname">addAll</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">iter</span> : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Adds all elements from the provided iterator to the end of the list.
Elements are added in the order they are returned by the iterator.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;

let array = [1, 1, 1];
let iter = array.vals();
let list = List.repeat&lt;Nat&gt;(2, 1);

List.addAll&lt;Nat&gt;(list, iter);
assert Iter.toArray(List.values(list)) == [2, 1, 1, 1];</code></pre>

<p>The maximum number of elements in a <code>List</code> is 2^32.</p>
<p>Runtime: <code>O(size)</code>, where n is the size of iter.</p>
</p></div><div class="declaration"><h4 class="function" id="toArray"><code><span class="keyword">public func </span><span class="fnname">toArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : [<span class="type">T</span>]</code></h4><p><p>Creates a new immutable array containing all elements from the list.
Elements appear in the same order as in the list.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.fromArray&lt;Nat&gt;([1, 2, 3]);

assert List.toArray&lt;Nat&gt;(list) == [1, 2, 3];</code></pre>

<p>Runtime: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="fromArray"><code><span class="keyword">public func </span><span class="fnname">fromArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">array</span> : [<span class="type">T</span>]) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a List containing elements from an Array.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;

let array = [2, 3];
let list = List.fromArray&lt;Nat&gt;(array);
assert Iter.toArray(List.values(list)) == [2, 3];</code></pre>

<p>Runtime: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="toVarArray"><code><span class="keyword">public func </span><span class="fnname">toVarArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : [<span class="keyword">var </span><span class="type">T</span>]</code></h4><p><p>Creates a new mutable array containing all elements from the list.
Elements appear in the same order as in the list.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Array &quot;mo:base/Array&quot;;

let list = List.fromArray&lt;Nat&gt;([1, 2, 3]);

let varArray = List.toVarArray&lt;Nat&gt;(list);
assert Array.fromVarArray(varArray) == [1, 2, 3];</code></pre>

<p>Runtime: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="fromVarArray"><code><span class="keyword">public func </span><span class="fnname">fromVarArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">array</span> : [<span class="keyword">var </span><span class="type">T</span>]) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a new List containing all elements from the mutable array.
Elements appear in the same order as in the array.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;

let array = [var 2, 3];
let list = List.fromVarArray&lt;Nat&gt;(array);
assert Iter.toArray(List.values(list)) == [2, 3];</code></pre>

<p>Runtime: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="first"><code><span class="keyword">public func </span><span class="fnname">first</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Returns the first element of <code>list</code>, or <code>null</code> if the list is empty.</p>
<p>Example:</p>
<pre><code>motoko include=import
assert List.first(List.fromArray&lt;Nat&gt;([1, 2, 3])) == ?1;
assert List.first(List.empty&lt;Nat&gt;()) == null;</code></pre>

<p>Runtime: <code>O(1)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="last"><code><span class="keyword">public func </span><span class="fnname">last</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Returns the last element of <code>list</code>. Traps if <code>list</code> is empty.</p>
<p>Example:</p>
<pre><code>motoko include=import
assert List.last(List.fromArray&lt;Nat&gt;([1, 2, 3])) == ?3;
assert List.last(List.empty&lt;Nat&gt;()) == null;</code></pre>

<p>Runtime: <code>O(1)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="forEach"><code><span class="keyword">public func </span><span class="fnname">forEach</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; ())</code></h4><p><p>Applies <code>f</code> to each element in <code>list</code>.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

let list = List.fromArray&lt;Nat&gt;([1, 2, 3]);

List.forEach&lt;Nat&gt;(list, func(x) {
  Debug.print(Nat.toText(x)); // prints each element in list
});</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="forEachEntry"><code><span class="keyword">public func </span><span class="fnname">forEachEntry</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : (<span class="type">Nat</span>, <span class="type">T</span>) -&gt; ())</code></h4><p><p>Applies <code>f</code> to each item <code>(i, x)</code> in <code>list</code> where <code>i</code> is the key
and <code>x</code> is the value.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

let list = List.fromArray&lt;Nat&gt;([1, 2, 3]);

List.forEachEntry&lt;Nat&gt;(list, func (i,x) {
  // prints each item (i,x) in list
  Debug.print(Nat.toText(i) # Nat.toText(x));
});</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="reverseForEachEntry"><code><span class="keyword">public func </span><span class="fnname">reverseForEachEntry</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : (<span class="type">Nat</span>, <span class="type">T</span>) -&gt; ())</code></h4><p><p>Like <code>forEachEntryRev</code> but iterates through the list in reverse order,
from end to beginning.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

let list = List.fromArray&lt;Nat&gt;([1, 2, 3]);

List.reverseForEachEntry&lt;Nat&gt;(list, func (i,x) {
  // prints each item (i,x) in list
  Debug.print(Nat.toText(i) # Nat.toText(x));
});</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="reverseForEach"><code><span class="keyword">public func </span><span class="fnname">reverseForEach</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; ())</code></h4><p><p>Applies <code>f</code> to each element in <code>list</code> in reverse order.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

let list = List.fromArray&lt;Nat&gt;([1, 2, 3]);

List.reverseForEach&lt;Nat&gt;(list, func (x) {
  Debug.print(Nat.toText(x)); // prints each element in list in reverse order
});</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="contains"><code><span class="keyword">public func </span><span class="fnname">contains</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Returns true if the list contains the specified element according to the provided
equality function. Uses the provided <code>equal</code> function to compare elements.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.empty&lt;Nat&gt;();
List.add(list, 2);
List.add(list, 0);
List.add(list, 3);

assert List.contains&lt;Nat&gt;(list, Nat.equal, 2);</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="max"><code><span class="keyword">public func </span><span class="fnname">max</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>) : ?<span class="type">T</span></code></h4><p><p>Returns the greatest element in the list according to the ordering defined by <code>compare</code>.
Returns <code>null</code> if the list is empty.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.empty&lt;Nat&gt;();
List.add(list, 1);
List.add(list, 2);

assert List.max&lt;Nat&gt;(list, Nat.compare) == ?2;
assert List.max&lt;Nat&gt;(List.empty&lt;Nat&gt;(), Nat.compare) == null;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="min"><code><span class="keyword">public func </span><span class="fnname">min</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>) : ?<span class="type">T</span></code></h4><p><p>Returns the least element in the list according to the ordering defined by <code>compare</code>.
Returns <code>null</code> if the list is empty.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.empty&lt;Nat&gt;();
List.add(list, 1);
List.add(list, 2);

assert List.min&lt;Nat&gt;(list, Nat.compare) == ?1;
assert List.min&lt;Nat&gt;(List.empty&lt;Nat&gt;(), Nat.compare) == null;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="equal"><code><span class="keyword">public func </span><span class="fnname">equal</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Tests if two lists are equal by comparing their elements using the provided <code>equal</code> function.
Returns true if and only if both lists have the same size and all corresponding elements
are equal according to the provided function.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list1 = List.fromArray&lt;Nat&gt;([1,2]);
let list2 = List.empty&lt;Nat&gt;();
List.add(list2, 1);
List.add(list2, 2);

assert List.equal&lt;Nat&gt;(list1, list2, Nat.equal);</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="compare"><code><span class="keyword">public func </span><span class="fnname">compare</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="Order.html#type.Order"><span class="type">Order.Order</span></a></code></h4><p><p>Compares two lists lexicographically using the provided <code>compare</code> function.
Elements are compared pairwise until a difference is found or one list ends.
If all elements compare equal, the shorter list is considered less than the longer list.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list1 = List.fromArray&lt;Nat&gt;([0, 1]);
let list2 = List.fromArray&lt;Nat&gt;([2]);
let list3 = List.fromArray&lt;Nat&gt;([0, 1, 2]);

assert List.compare&lt;Nat&gt;(list1, list2, Nat.compare) == #less;
assert List.compare&lt;Nat&gt;(list1, list3, Nat.compare) == #less;
assert List.compare&lt;Nat&gt;(list2, list3, Nat.compare) == #greater;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="toText"><code><span class="keyword">public func </span><span class="fnname">toText</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Text</span>) : <span class="type">Text</span></code></h4><p><p>Creates a textual representation of <code>list</code>, using <code>toText</code> to recursively
convert the elements into Text.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.fromArray&lt;Nat&gt;([1,2,3,4]);

assert List.toText&lt;Nat&gt;(list, Nat.toText) == &quot;List[1, 2, 3, 4]&quot;;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that <code>toText</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="foldLeft"><code><span class="keyword">public func </span><span class="fnname">foldLeft</span>&lt;<span class="type">A</span>, <span class="type">T</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">A</span>, <span class="type">T</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in <code>list</code> into a single value by starting with <code>base</code>
and progessively combining elements into <code>base</code> with <code>combine</code>. Iteration runs
left to right.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.fromArray&lt;Nat&gt;([1,2,3]);

assert List.foldLeft&lt;Text, Nat&gt;(list, &quot;&quot;, func (acc, x) { acc # Nat.toText(x)}) == &quot;123&quot;;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>combine</code> runs in O(1)` time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="foldRight"><code><span class="keyword">public func </span><span class="fnname">foldRight</span>&lt;<span class="type">T</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">T</span>, <span class="type">A</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in <code>list</code> into a single value by starting with <code>base</code>
and progessively combining elements into <code>base</code> with <code>combine</code>. Iteration runs
right to left.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;

let list = List.fromArray&lt;Nat&gt;([1,2,3]);

assert List.foldRight&lt;Nat, Text&gt;(list, &quot;&quot;, func (x, acc) { Nat.toText(x) # acc }) == &quot;123&quot;;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that <code>combine</code> runs in O(1)` time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="reverseInPlace"><code><span class="keyword">public func </span><span class="fnname">reverseInPlace</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Reverses the order of elements in <code>list</code> by overwriting in place.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;

let list = List.fromArray&lt;Nat&gt;([1,2,3]);

List.reverseInPlace&lt;Nat&gt;(list);
assert Iter.toArray(List.values(list)) == [3, 2, 1];</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="reverse"><code><span class="keyword">public func </span><span class="fnname">reverse</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns a new List with the elements from <code>list</code> in reverse order.</p>
<p>Example:</p>
<pre><code>motoko include=import
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;

let list = List.fromArray&lt;Nat&gt;([1,2,3]);

let rlist = List.reverse&lt;Nat&gt;(list);
assert Iter.toArray(List.values(rlist)) == [3, 2, 1];</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Returns true if and only if the list is empty.</p>
<p>Example:</p>
<pre><code>motoko include=import
let list = List.fromArray&lt;Nat&gt;([2,0,3]);
assert not List.isEmpty&lt;Nat&gt;(list);
assert List.isEmpty&lt;Nat&gt;(List.empty&lt;Nat&gt;());</code></pre>

<p>Runtime: <code>O(1)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div></div></body></html>