<!DOCTYPE html>
<html><head title="Motoko docs"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><div class="index-container"><h1 class="index-header">Index of modules</h1><ul class="index-listing"><li class="index-item"><a class="index-item-link" href="Array.html">Array</a><div class="index-item-comment"><p>Provides extended utility functions on Arrays.</p>
<p>Note the difference between mutable and non-mutable arrays below.</p>
<p>WARNING: If you are looking for a list that can grow and shrink in size,
it is recommended you use <code>List</code> for those purposes.
Arrays must be created with a fixed size.</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Array &quot;mo:base/Array&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Blob.html">Blob</a><div class="index-item-comment"><p>Module for working with Blobs (immutable sequences of bytes).</p>
<p>Blobs represent sequences of bytes. They are immutable, iterable, but not indexable and can be empty.</p>
<p>Byte sequences are also often represented as <code>[Nat8]</code>, i.e. an array of bytes, but this representation is currently much less compact than <code>Blob</code>, taking 4 physical bytes to represent each logical byte in the sequence.
If you would like to manipulate Blobs, it is recommended that you convert
Blobs to <code>[var Nat8]</code> or <code>Buffer&lt;Nat8&gt;</code>, do the manipulation, then convert back.</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Blob &quot;mo:base/Blob&quot;;</code></pre>

<p>Some built in features not listed in this module:</p>
<ul><li>You can create a <code>Blob</code> literal from a <code>Text</code> literal, provided the context expects an expression of type <code>Blob</code>.</li><li><code>b.size() : Nat</code> returns the number of bytes in the blob <code>b</code>;</li><li><code>b.values() : Iter.Iter&lt;Nat8&gt;</code> returns an iterator to enumerate the bytes of the blob <code>b</code>.</li></ul>

<p>For example:</p>
<pre><code>motoko include=import
import Debug &quot;mo:base/Debug&quot;;
import Nat8 &quot;mo:base/Nat8&quot;;

let blob = &quot;\00\00\00\ff&quot; : Blob; // blob literals, where each byte is delimited by a back-slash and represented in hex
let blob2 = &quot;chars„ÇÇ„ÅÇ„Çä&quot; : Blob; // you can also use characters in the literals
let numBytes = blob.size(); // =&gt; 4 (returns the number of bytes in the Blob)
for (byte : Nat8 in blob.values()) { // iterator over the Blob
  Debug.print(Nat8.toText(byte))
}</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Bool.html">Bool</a><div class="index-item-comment"><p>Boolean type and operations.</p>
<p>While boolean operators <code>_ and _</code> and <code>_ or _</code> are short-circuiting,
avoiding computation of the right argument when possible, the functions
<code>logand(_, _)</code> and <code>logor(_, _)</code> are <em>strict</em> and will always evaluate <em>both</em>
of their arguments.</p>
</div></li><li class="index-item"><a class="index-item-link" href="CertifiedData.html">CertifiedData</a><div class="index-item-comment"><p>Certified data.</p>
<p>The Internet Computer allows canister smart contracts to store a small amount of data during
update method processing so that during query call processing, the canister can obtain
a certificate about that data.</p>
<p>This module provides a <em>low-level</em> interface to this API, aimed at advanced
users and library implementors. See the Internet Computer Functional
Specification and corresponding documentation for how to use this to make query
calls to your canister tamperproof.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Char.html">Char</a><div class="index-item-comment"><p>Utilities for <code>Char</code> (character)</p>
</div></li><li class="index-item"><a class="index-item-link" href="Cycles.html">Cycles</a><div class="index-item-comment"><p>Managing cycles within actors in the Internet Computer Protocol (ICP).</p>
<p>The usage of the Internet Computer is measured, and paid for, in <em>cycles</em>.
This library provides imperative operations for observing cycles, transferring cycles, and
observing refunds of cycles.</p>
<p><strong>NOTE:</strong> Since cycles measure computational resources, the value of  <code>balance()</code> can change from one call to the next.</p>
<p>Cycles can be transferred from the current actor to another actor with the evaluation of certain forms of expression.
In particular, the expression must be a call to a shared function, a call to a local function with an <code>async</code> return type, or a simple <code>async</code> expression.
To attach an amount of cycles to an expression <code>&lt;exp&gt;</code>, simply prefix the expression with <code>(with cycles = &lt;amount&gt;)</code>, that is, <code>(with cycles = &lt;amount&gt;) &lt;exp&gt;</code>.</p>
<p><strong>NOTE:</strong> Attaching cycles will trap if the amount specified exceeds <code>2 ** 128</code> cycles.</p>
<p>Upon the call, but not before, the amount of cycles is deducted from <code>balance()</code>.
If this total exceeds <code>balance()</code>, the caller traps, aborting the call without consuming the cycles.
Note that attaching cycles to a call to a local function call or <code>async</code> expression just transfers cycles from the current actor to itself.</p>
<p>Example for use on the ICP:</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:base/Cycles&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor {
  public func main() : async() {
    Debug.print(&quot;Main balance: &quot; # debug_show(Cycles.balance()));
    await (with cycles = 15_000_000) operation(); // accepts 10_000_000 cycles
    Debug.print(&quot;Main refunded: &quot; # debug_show(Cycles.refunded())); // 5_000_000
    Debug.print(&quot;Main balance: &quot; # debug_show(Cycles.balance())); // decreased by around 10_000_000
  };

  func operation() : async() {
    Debug.print(&quot;Operation balance: &quot; # debug_show(Cycles.balance()));
    Debug.print(&quot;Operation available: &quot; # debug_show(Cycles.available()));
    let obtained = Cycles.accept&lt;system&gt;(10_000_000);
    Debug.print(&quot;Operation obtained: &quot; # debug_show(obtained)); // =&gt; 10_000_000
    Debug.print(&quot;Operation balance: &quot; # debug_show(Cycles.balance())); // increased by 10_000_000
    Debug.print(&quot;Operation available: &quot; # debug_show(Cycles.available())); // decreased by 10_000_000
  }
}</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Debug.html">Debug</a><div class="index-item-comment"><p>Utility functions for debugging.</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Debug &quot;mo:base/Debug&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Error.html">Error</a><div class="index-item-comment"><p>Error values and inspection.</p>
<p>The <code>Error</code> type is the argument to <code>throw</code>, parameter of <code>catch</code>.
The <code>Error</code> type is opaque.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Float.html">Float</a><div class="index-item-comment"><p>Double precision (64-bit) floating-point numbers in IEEE 754 representation.</p>
<p>This module contains common floating-point constants and utility functions.</p>
<p>Notation for special values in the documentation below:
<code>+inf</code>: Positive infinity
<code>-inf</code>: Negative infinity
<code>NaN</code>: &quot;not a number&quot; (can have different sign bit values, but <code>NaN != NaN</code> regardless of the sign).</p>
<p>Note:
Floating point numbers have limited precision and operations may inherently result in numerical errors.</p>
<p>Examples of numerical errors:</p>
<pre class="motoko"><code class="motoko">  0.1 + 0.1 + 0.1 == 0.3 // =&gt; false
  </code></pre>

<pre class="motoko"><code class="motoko"> 1e16 + 1.0 != 1e16 // =&gt; false
  </code></pre>

<p> (and many more cases)</p>
<p>Advice:</p>
<ul><li>Floating point number comparisons by <code>==</code> or <code>!=</code> are discouraged. Instead, it is better to compare
 floating-point numbers with a numerical tolerance, called epsilon.</li></ul>

<p> Example:</p>
<pre class="motoko"><code class="motoko">  import Float &quot;mo:base/Float&quot;;
  let x = 0.1 + 0.1 + 0.1;
  let y = 0.3;

  let epsilon = 1e-6; // This depends on the application case (needs a numerical error analysis).
  Float.equal(x, y, epsilon) // =&gt; true
  </code></pre>

<ul><li>For absolute precision, it is recommened to encode the fraction number as a pair of a Nat for the base
 and a Nat for the exponent (decimal point).</li></ul>

<p>NaN sign:</p>
<ul><li>The NaN sign is only applied by <code>abs</code>, <code>neg</code>, and <code>copySign</code>. Other operations can have an arbitrary
 sign bit for NaN results.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Func.html">Func</a><div class="index-item-comment"><p>Functions on functions, creating functions from simpler inputs.</p>
<p>(Most commonly used when programming in functional style using higher-order
functions.)</p>
</div></li><li class="index-item"><a class="index-item-link" href="Int.html">Int</a><div class="index-item-comment"><p>Signed integer numbers with infinite precision (also called big integers).</p>
<p>Most operations on integer numbers (e.g. addition) are available as built-in operators (e.g. <code>-1 + 1</code>).
This module provides equivalent functions and <code>Text</code> conversion.</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Int &quot;mo:base/Int&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int16.html">Int16</a><div class="index-item-comment"><p>Utility functions on 16-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Int16 &quot;mo:base/Int16&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int32.html">Int32</a><div class="index-item-comment"><p>Utility functions on 32-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Int32 &quot;mo:base/Int32&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int64.html">Int64</a><div class="index-item-comment"><p>Utility functions on 64-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Int64 &quot;mo:base/Int64&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int8.html">Int8</a><div class="index-item-comment"><p>Utility functions on 8-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Int8 &quot;mo:base/Int8&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="InternetComputer.html">InternetComputer</a><div class="index-item-comment"><p>Low-level interface to the Internet Computer.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Iter.html">Iter</a><div class="index-item-comment"><p>Utilities for <code>Iter</code> (iterator) values.</p>
<p>Iterators are a way to represent sequences of values that can be lazily produced.
They can be used to:</p>
<ul><li>Iterate over collections.</li><li>Represent collections that are too large to fit in memory or that are produced incrementally.</li><li>Transform collections without creating intermediate collections.</li></ul>

<p>Iterators are inherently stateful. Calling <code>next</code> &quot;consumes&quot; a value from
the Iterator that cannot be put back, so keep that in mind when sharing
iterators between consumers.</p>
<p>An iterator <code>i</code> can be iterated over using</p>
<pre class="motoko"><code class="motoko">for (x in i) {
  ‚Ä¶do something with x‚Ä¶
}</code></pre>

<p>Iterators can be:</p>
<ul><li>created from other collections (e.g. using <code>values</code> or <code>keys</code> function on a <code>Map</code>) or from scratch (e.g. using <code>empty</code> or <code>singleton</code>).</li><li>transformed using <code>map</code>, <code>filter</code>, <code>concat</code>, etc. Which can be used to compose several transformations together without materializing intermediate collections.</li><li>consumed using <code>forEach</code>, <code>size</code>, <code>toArray</code>, etc.</li><li>combined using <code>concat</code>.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="List.html">List</a><div class="index-item-comment"><p>Resizable array with <code>O(sqrt(n))</code> memory overhead.
Static type <code>List</code> that can be declared <code>stable</code>.
For the <code>List</code> class see the file Class.mo.</p>
<p>This implementation is adapted with permission from the <code>vector</code> Mops package created by Research AG.</p>
<p>Copyright: 2023 MR Research AG
Main author: Andrii Stepanov
Contributors: Timo Hanke (timohanke), Andy Gura (andygura), react0r-com</p>
</div></li><li class="index-item"><a class="index-item-link" href="Map.html">Map</a><div class="index-item-comment"><p>An imperative key-value map based on order/comparison of the keys.
The map data structure type is stable and can be used for orthogonal persistence.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let numberNames = Map.empty&lt;Nat, Text&gt;();
  Map.add(numberNames, Nat.compare, 0, &quot;Zero&quot;);
  Map.add(numberNames, Nat.compare, 1, &quot;One&quot;);
  Map.add(numberNames, Nat.compare, 2, &quot;Two&quot;);
}</code></pre>

<p>The internal implementation is a B-tree with order 32.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire map.
<code>n</code> denotes the number of key-value entries stored in the map.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Nat.html">Nat</a><div class="index-item-comment"><p>Natural numbers with infinite precision.</p>
<p>Most operations on natural numbers (e.g. addition) are available as built-in operators (e.g. <code>1 + 1</code>).
This module provides equivalent functions and <code>Text</code> conversion.</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Nat &quot;mo:base/Nat&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat16.html">Nat16</a><div class="index-item-comment"><p>Utility functions on 16-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Nat16 &quot;mo:base/Nat16&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat32.html">Nat32</a><div class="index-item-comment"><p>Utility functions on 32-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Nat32 &quot;mo:base/Nat32&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat64.html">Nat64</a><div class="index-item-comment"><p>Utility functions on 64-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Nat64 &quot;mo:base/Nat64&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat8.html">Nat8</a><div class="index-item-comment"><p>Utility functions on 8-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Nat8 &quot;mo:base/Nat8&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Option.html">Option</a><div class="index-item-comment"><p>Typesafe nullable values.</p>
<p>Optional values can be seen as a typesafe <code>null</code>. A value of type <code>?Int</code> can
be constructed with either <code>null</code> or <code>?42</code>. The simplest way to get at the
contents of an optional is to use pattern matching:</p>
<pre class="motoko"><code class="motoko">let optionalInt1 : ?Int = ?42;
let optionalInt2 : ?Int = null;

let int1orZero : Int = switch optionalInt1 {
  case null 0;
  case (?int) int;
};
assert int1orZero == 42;

let int2orZero : Int = switch optionalInt2 {
  case null 0;
  case (?int) int;
};
assert int2orZero == 0;</code></pre>

<p>The functions in this module capture some common operations when working
with optionals that can be more succinct than using pattern matching.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Order.html">Order</a><div class="index-item-comment"><p>Utilities for <code>Order</code> (comparison between two values).</p>
</div></li><li class="index-item"><a class="index-item-link" href="Principal.html">Principal</a><div class="index-item-comment"><p>Module for interacting with Principals (users and canisters).</p>
<p>Principals are used to identify entities that can interact with the Internet
Computer. These entities are either users or canisters.</p>
<p>Example textual representation of Principals:</p>
<p><code>un4fu-tqaaa-aaaab-qadjq-cai</code></p>
<p>In Motoko, there is a primitive Principal type called <code>Principal</code>. As an example
of where you might see Principals, you can access the Principal of the
caller of your shared function.</p>
<pre><code>motoko no-repl
shared(msg) func foo() {
  let caller : Principal = msg.caller;
};</code></pre>

<p>Then, you can use this module to work with the <code>Principal</code>.</p>
<p>Import from the base library to use this module.</p>
<pre><code>motoko name=import
import Principal &quot;mo:base/Principal&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Queue.html">Queue</a><div class="index-item-comment"><p>A mutable double-ended queue of elements.
The queue has two ends, front and back.
Elements can be added and removed at the two ends.</p>
<p>This can be used for different use cases, such as:</p>
<ul><li>Queue (FIFO) by using <code>pushBack()</code> and <code>popFront()</code></li><li>Stack (LIFO) by using <code>pushFront()</code> and <code>popFront()</code>.</li></ul>

<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;Queue&quot;;
import Debug &quot;Debug&quot;;

persistent actor {
  let orders = Queue.empty&lt;Text&gt;();
  Queue.pushBack(orders, &quot;Antipasta&quot;);
  Queue.pushBack(orders, &quot;Spaghetti&quot;);
  Queue.pushBack(orders, &quot;Bistecca&quot;);
  Queue.pushBack(orders, &quot;Dolce&quot;);
  label iteration loop {
    switch (Queue.popFront(orders)) {
      case null { break iteration };
      case (?description) {
        Debug.print(description)
      }
    }
  }
  // prints:
  // `Antipasta`
  // `Spaghetti`
  // `Bistecca`
  // `Dolce`
}</code></pre>

<p>The internal implementation is a doubly-linked list.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(1)</code> for push, pop, and peek operations.</li><li>Space: <code>O(n)</code>.
<code>n</code> denotes the number of elements stored in the queue.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Random.html">Random</a><div class="index-item-comment"><p>Random number generation.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Region.html">Region</a><div class="index-item-comment"><p>Byte-level access to isolated, virtual stable memory regions.</p>
<p>This is a moderately lightweight abstraction over IC <em>stable memory</em> and supports persisting
regions of binary data across Motoko upgrades.
Use of this module is fully compatible with Motoko's use of
<em>stable variables</em>, whose persistence mechanism also uses (real) IC stable memory internally, but does not interfere with this API.
It is also fully compatible with existing uses of the <code>ExperimentalStableMemory</code> library, which has a similar interface, but,
only supported a single memory region, without isolation between different applications.</p>
<p>The <code>Region</code> type is stable and can be used in stable data structures.</p>
<p>A new, empty <code>Region</code> is allocated using function <code>new()</code>.</p>
<p>Regions are stateful objects and can be distinguished by the numeric identifier returned by function <code>id(region)</code>.
Every region owns an initially empty, but growable sequence of virtual IC stable memory pages.
The current size, in pages, of a region is returned by function <code>size(region)</code>.
The size of a region determines the range, [ 0, ..., size(region)*2^16 ), of valid byte-offsets into the region; these offsets are used as the source and destination of <code>load</code>/<code>store</code> operations on the region.</p>
<p>Memory is allocated to a region, using function <code>grow(region, pages)</code>, sequentially and on demand, in units of 64KiB logical pages, starting with 0 allocated pages.
A call to <code>grow</code> may succeed, returning the previous size of the region, or fail, returning a sentinel value. New pages are zero initialized.</p>
<p>A size of a region can only grow and never shrink.
In addition, the stable memory pages allocated to a region will <em>not</em> be reclaimed by garbage collection, even
if the region object itself becomes unreachable.</p>
<p>Growth is capped by a soft limit on physical page count controlled by compile-time flag
<code>--max-stable-pages &lt;n&gt;</code> (the default is 65536, or 4GiB).</p>
<p>Each <code>load</code> operation loads from region relative byte address <code>offset</code> in little-endian
format using the natural bit-width of the type in question.
The operation traps if attempting to read beyond the current region size.</p>
<p>Each <code>store</code> operation stores to region relative byte address <code>offset</code> in little-endian format using the natural bit-width of the type in question.
The operation traps if attempting to write beyond the current region size.</p>
<p>Text values can be handled by using <code>Text.decodeUtf8</code> and <code>Text.encodeUtf8</code>, in conjunction with <code>loadBlob</code> and <code>storeBlob</code>.</p>
<p>The current region allocation and region contents are preserved across upgrades.</p>
<p>NB: The IC's actual stable memory size (<code>ic0.stable_size</code>) may exceed the
total page size reported by summing all regions sizes.
This (and the cap on growth) are to accommodate Motoko's stable variables and bookkeeping for regions.
Applications that plan to use Motoko stable variables sparingly or not at all can
increase <code>--max-stable-pages</code> as desired, approaching the IC maximum (initially 8GiB, then 32Gib, currently 64Gib).
All applications should reserve at least one page for stable variable data, even when no stable variables are used.</p>
<p>Usage:</p>
<pre><code>motoko no-repl
import Region &quot;mo:base/Region&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Result.html">Result</a><div class="index-item-comment"><p>Error handling with the Result type.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Runtime.html">Runtime</a><div class="index-item-comment"></div></li><li class="index-item"><a class="index-item-link" href="Set.html">Set</a><div class="index-item-comment"><p>An imperative set based on order/comparison of the elements.
A set is a collection of elements without duplicates.
The set data structure type is stable and can be used for orthogonal persistence.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let userIds = Set.empty&lt;Nat&gt;();
  Set.add(userIds, Nat.compare, 1);
  Set.add(userIds, Nat.compare, 2);
  Set.add(userIds, Nat.compare, 3);
}</code></pre>

<p>The internal implementation is a B-tree with order 32.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire set.
<code>n</code> denotes the number of elements stored in the set.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Stack.html">Stack</a><div class="index-item-comment"><p>A mutable stack data structure.
Elements can be pushed on top of the stack
and removed from top of the stack (LIFO).</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Stack &quot;Stack&quot;;
import Debug &quot;Debug&quot;;

persistent actor {
  let levels = Stack.empty&lt;Text&gt;();
  Stack.push(levels, &quot;Inner&quot;);
  Stack.push(levels, &quot;Middle&quot;);
  Stack.push(levels, &quot;Outer&quot;);
  label iteration loop {
    switch (Stack.pop(levels)) {
      case null { break iteration };
      case (?name) {
        Debug.print(name)
      }
    }
  }
  // prints:
  // `Outer`
  // `Middle`
  // `Inner`
}</code></pre>

<p>The internal implementation is a singly-linked list.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(1)</code> for push, pop, and peek operation.</li><li>Space: <code>O(n)</code>.
<code>n</code> denotes the number of elements stored on the stack.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Text.html">Text</a><div class="index-item-comment"><p>Utility functions for <code>Text</code> values.</p>
<p>A <code>Text</code> value represents human-readable text as a sequence of characters of type <code>Char</code>.</p>
<pre class="motoko"><code class="motoko">let text = &quot;Hello!&quot;;
let size = text.size(); // 6
let iter = text.chars(); // iterator ('H', 'e', 'l', 'l', 'o', '!')
let concat = text # &quot; üëã&quot;; // &quot;Hello! üëã&quot;</code></pre>

<p>The <code>&quot;mo:base/Text&quot;</code> module defines additional operations on <code>Text</code> values.</p>
<p>Import the module from the base library:</p>
<pre><code>motoko name=import
import Text &quot;mo:base/Text&quot;;</code></pre>

<p>Note: <code>Text</code> values are represented as ropes of UTF-8 character sequences with O(1) concatenation.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Time.html">Time</a><div class="index-item-comment"><p>System time utilities and timers.</p>
<p>The following example illustrates using the system time:</p>
<pre class="motoko"><code class="motoko">import Int = &quot;mo:base/Int&quot;;
import Time = &quot;mo:base/Time&quot;;

actor {
  var lastTime = Time.now();
  public func greet(name : Text) : async Text {
    let now = Time.now();
    let elapsedSeconds = (now - lastTime) / 1000_000_000;
    lastTime := now;
    return &quot;Hello, &quot; # name # &quot;!&quot; #
      &quot; I was last called &quot; # Int.toText(elapsedSeconds) # &quot; seconds ago&quot;;
   };
};</code></pre>

<p>Note: If <code>moc</code> is invoked with <code>-no-timer</code>, the importing will fail.
Note: The resolution of the timers is in the order of the block rate,</p>
<pre><code>  so durations should be chosen well above that. For frequent
  canister wake-ups the heartbeat mechanism should be considered.</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Timer.html">Timer</a><div class="index-item-comment"><p>Timers for one-off or periodic tasks. Applicable as part of the default mechanism.
If <code>moc</code> is invoked with <code>-no-timer</code>, the importing will fail. Furthermore, if passed <code>--trap-on-call-error</code>, a congested canister send queue may prevent timer expirations to execute at runtime. It may also deactivate the global timer.</p>
<p>The resolution of the timers is similar to the block rate,
so durations should be chosen well above that. For frequent
canister wake-ups, consider using the <a href="https://internetcomputer.org/docs/current/motoko/main/writing-motoko/heartbeats">heartbeat</a> mechanism; however, when possible, canisters should prefer timers.</p>
<p>The functionality described below is enabled only when the actor does not override it by declaring an explicit <code>system func timer</code>.</p>
<p>Timers are <em>not</em> persisted across upgrades. One possible strategy
to re-establish timers after an upgrade is to use stable variables
in the <code>post_upgrade</code> hook and distill necessary timer information
from there.</p>
<p>Using timers for security (e.g., access control) is strongly discouraged.
Make sure to inform yourself about state-of-the-art dapp security.
If you must use timers for security controls, be sure
to consider reentrancy issues as well as the vanishing of timers on upgrades
and reinstalls.</p>
<p>For further usage information for timers on the IC, please consult
<a href="https://internetcomputer.org/docs/current/developer-docs/backend/periodic-tasks#timers-library-limitations">the documentation</a>.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Tuples.html">Tuples</a><div class="index-item-comment"><p>Contains modules for working with tuples of different sizes.</p>
<p>Usage example:</p>
<pre class="motoko"><code class="motoko">import { Tuple2; Tuple3 } &quot;mo:base/Tuples&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Text &quot;mo:base/Text&quot;;

let swapped = Tuple2.swap((1, &quot;hello&quot;)); // (&quot;hello&quot;, 1)
let text = Tuple3.toText((1, &quot;hello&quot;, 3), Nat.toText, Text.toText, Nat.toText); // &quot;(1, hello, 3)&quot;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Types.html">Types</a><div class="index-item-comment"></div></li><li class="index-item"><a class="index-item-link" href="VarArray.html">VarArray</a><div class="index-item-comment"><p>Mutable array utilities.</p>
</div></li><li class="index-item"><a class="index-item-link" href="internal/BTreeHelper.html">internal/BTreeHelper</a><div class="index-item-comment"></div></li><li class="index-item"><a class="index-item-link" href="internal/PRNG.html">internal/PRNG</a><div class="index-item-comment"><p>Collection of pseudo-random number generators</p>
<p>The algorithms deliver deterministic statistical randomness,
not cryptographic randomness.</p>
<p>Algorithm 1: 128-bit Seiran PRNG
See: https://github.com/andanteyk/prng-seiran</p>
<p>Algorithm 2: SFC64 and SFC32 (Chris Doty-Humphrey‚Äôs Small Fast Chaotic PRNG)
See: https://numpy.org/doc/stable/reference/random/bit_generators/sfc64.html</p>
<p>Copyright: 2023 MR Research AG
Main author: react0r-com
Contributors: Timo Hanke (timohanke)</p>
</div></li><li class="index-item"><a class="index-item-link" href="pure/List.html">pure/List</a><div class="index-item-comment"><p>Purely-functional, singly-linked lists.
A list of type <code>List&lt;T&gt;</code> is either <code>null</code> or an optional pair of a value of type <code>T</code> and a tail, itself of type <code>List&lt;T&gt;</code>.</p>
<p>To use this library, import it using:</p>
<pre><code>motoko name=initialize
import List &quot;mo:base/List&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="pure/Map.html">pure/Map</a><div class="index-item-comment"><p>Immutable, ordered key-value maps.</p>
<p>The map type is stable whenever the key and value types are stable, allowing
map values to be stored in stable variables.</p>
<p>Keys are ordered by an explicit <code>compare</code> function, which <em>must</em> be the same
across all operations on a given map.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  // creation
  let empty = Map.empty&lt;Nat, Text&gt;();
  // insertion
  let map1 = Map.add(empty, Nat.compare, 0, &quot;Zero&quot;);
  // retrieval
  let null = Map.get(empty, Nat.compare, 0);
  let ?&quot;Zero&quot; = Map.get(map1, Nat.compare, 0);
  // deletion
  let map2 = Map.delete(map1, Nat.compare, 0);
  assert not Map.isEmpty(map1);
  assert Map.isEmpty(map2);
}</code></pre>

<p>The internal representation is a red-black tree.</p>
<p>A red-black tree is a balanced binary search tree ordered by the keys.</p>
<p>The tree data structure internally colors each of its nodes either red or black,
and uses this information to balance the tree during the modifying operations.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire tree.
<code>n</code> denotes the number of key-value entries (i.e. nodes) stored in the tree.</li></ul>

<p>Note:</p>
<ul><li>Map operations, such as retrieval, insertion, and removal create <code>O(log(n))</code> temporary objects that become garbage.</li></ul>

<p>Credits:</p>
<p>The core of this implementation is derived from:</p>
<ul><li>Ken Friis Larsen's <a href="https://github.com/kfl/mosml/blob/master/src/mosmllib/Redblackmap.sml">RedBlackMap.sml</a>, which itself is based on:</li><li>Stefan Kahrs, &quot;Red-black trees with types&quot;, Journal of Functional Programming, 11(4): 425-432 (2001), <a href="http://www.cs.ukc.ac.uk/people/staff/smk/redblack/rb.html">version 1 in web appendix</a>.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="pure/Queue.html">pure/Queue</a><div class="index-item-comment"><p>Double-ended queue of a generic element type <code>T</code>.</p>
<p>The interface is purely functional, not imperative, and queues are immutable values.
In particular, Queue operations such as push and pop do not update their input queue but, instead, return the
value of the modified Queue, alongside any other data.
The input queue is left unchanged.</p>
<p>Examples of use-cases:
Queue (FIFO) by using <code>pushBack()</code> and <code>popFront()</code>.
Stack (LIFO) by using <code>pushFront()</code> and <code>popFront()</code>.</p>
<p>A Queue is internally implemented as two lists, a head access list and a (reversed) tail access list,
that are dynamically size-balanced by splitting.</p>
<p>Construction: Create a new queue with the <code>empty&lt;T&gt;()</code> function.</p>
<p>Note on the costs of push and pop functions:</p>
<ul><li>Runtime: <code>O(1)</code> amortized costs, <code>O(n)</code> worst case cost per single call.</li><li>Space: <code>O(1)</code> amortized costs, <code>O(n)</code> worst case cost per single call.</li></ul>

<p><code>n</code> denotes the number of elements stored in the queue.</p>
</div></li><li class="index-item"><a class="index-item-link" href="pure/Set.html">pure/Set</a><div class="index-item-comment"><p>Stable ordered set implemented as a red-black tree.</p>
<p>A red-black tree is a balanced binary search tree ordered by the elements.</p>
<p>The tree data structure internally colors each of its nodes either red or black,
and uses this information to balance the tree during modifying operations.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire tree.
<code>n</code> denotes the number of elements (i.e. nodes) stored in the tree.</li></ul>

<p>Credits:</p>
<p>The core of this implementation is derived from:</p>
<ul><li>Ken Friis Larsen's <a href="https://github.com/kfl/mosml/blob/master/src/mosmllib/Redblackmap.sml">RedBlackMap.sml</a>, which itself is based on:</li><li>Stefan Kahrs, &quot;Red-black trees with types&quot;, Journal of Functional Programming, 11(4): 425-432 (2001), <a href="http://www.cs.ukc.ac.uk/people/staff/smk/redblack/rb.html">version 1 in web appendix</a>.</li></ul></div></li></ul></div></html>